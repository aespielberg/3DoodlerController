#include <openrave/openrave.h>
#include <boost/bind.hpp>
#include <boost/lexical_cast.hpp>

#include "ros/ros.h"
#include "std_msgs/String.h"
#include "sensor_msgs/JointState.h"
#include "geometry_msgs/Twist.h"

#include "brics_actuator/JointValue.h"
#include "brics_actuator/JointPositions.h"

#include "assembly_common/BasePose.h"
#include "assembly_common/BaseCommand.h"

#include <boost/units/systems/si/length.hpp>
#include <boost/units/systems/si/plane_angle.hpp>
#include <boost/units/systems/si/velocity.hpp>
#include <boost/units/io.hpp>

#include <boost/units/systems/angle/degrees.hpp>
#include <boost/units/conversion.hpp>

#include <boost/algorithm/string.hpp>
#include <cstddef>
#include <math.h>
#include <cmath>
#include <algorithm>
#include <exception>

using namespace std;
using namespace OpenRAVE;


class YoubotController : public ControllerBase
{
public:
	YoubotController(EnvironmentBasePtr penv, std::istream& sinput) : ControllerBase(penv) //, cmdid(0), _bPause(false), _bIsDone(true), _bCheckCollision(false), _bThrowExceptions(false)
	{
		__description = ":Interface Author: Dalitso Banda";

		RegisterCommand("MoveArm", boost::bind(&YoubotController::MoveArm, this, _1, _2), "moves the arm ");
		RegisterCommand("MoveGripper", boost::bind(&YoubotController::MoveGripper, this, _1, _2), "moves the gripper ");
		RegisterCommand("MoveBase", boost::bind(&YoubotController::MoveBase, this, _1, _2), "moves the base ");
		RegisterCommand("Pause", boost::bind(&YoubotController::Pause, this, _1, _2), "Pauses the controller.");
		RegisterCommand("Resume", boost::bind(&YoubotController::Resume, this, _1, _2), "Resumes the controller.");

		//RegisterCommand("SetThrowExceptions",boost::bind(&YoubotController::_SetThrowExceptions,this,_1,_2),
		//                "If set, will throw exceptions instead of print warnings. Format is:\n\n  [0/1]");

		_nControlTransformation = 0;
		_penv = penv;
                _paused = false;
	}

	bool Pause(ostream& sout, istream& sinput)
	{
            _paused = true;
            sout << "True";
	    return true;
	}

	bool Resume(ostream& sout, istream& sinput)
	{
            _paused = false;
            sout << "True";
	    return true;
	}
	
	bool MoveArm(ostream& sout, istream& sinput){
	    std::string valuesString;
	    sinput >> valuesString;

		ROS_INFO("input %s", valuesString.c_str());

		vector<std::string> valuestokens;
		boost::split(valuestokens, valuesString, boost::is_any_of("\t,"));

		vector<double> values;

		for (size_t i = 0; i < valuestokens.size(); ++i)
		{
			values.push_back(boost::lexical_cast<double>(valuestokens[i]));
		}
		
		bool ret_val = MoveArm(values);
		
		if (ret_val){
		    sout << "True";
		    return true;
		}
		sout << "False";
		return false;
	}

	bool MoveArm(vector<double> values)
	{
        if (ros::ok() && !_paused){
            
		    for (size_t i = 0; i < _offset.size(); ++i)
		    {
		        /*
		        std::cout << "loop: " << i << std::endl;
		        std::cout << values[i] << std::endl;
		        std::cout << _offset.size() << std::endl;
		        std::cout << _offset.at(i) << std::endl;
		        */
			    values[i] += _offset.at(i);
		    }
        
        
			brics_actuator::JointPositions command;
			vector <brics_actuator::JointValue> armJointPositions;

			vector <std::string> armJointNames;
			armJointPositions.resize(5);
			armJointNames.resize(5);

			armJointNames[0] = "arm_joint_1";
			armJointNames[1] = "arm_joint_2";
			armJointNames[2] = "arm_joint_3";
			armJointNames[3] = "arm_joint_4";
			armJointNames[4] = "arm_joint_5";


			for (int i = 0; i < 5; ++i)
			{
				armJointPositions[i].joint_uri = armJointNames[i].c_str();
				armJointPositions[i].value = values[i];
				armJointPositions[i].unit = std::string("rad");
			}

			command.positions = armJointPositions;
			ROS_INFO("the values are %f %f %f %f %f", values[0], values[1], values[2], values[3], values[4]);
			_move_arm_pub.publish(command);

			// Store last values for later.
			_last_arm_command = values;

			return true;
		}
		return false;
	}
	
	bool MoveGripper(ostream& sout, istream& sinput)
	{
		if (ros::ok() && !_paused)
		{
			std::string valuesString;
			sinput >> valuesString;
			ROS_INFO("input %s", valuesString.c_str());

			vector<std::string> valuestokens;
			boost::split(valuestokens, valuesString, boost::is_any_of("\t,"));

			vector<double> values;
			for (size_t i = 0; i < valuestokens.size(); ++i)
			{
				values.push_back(boost::lexical_cast<double>(valuestokens[i]));
			}

			brics_actuator::JointPositions command;
			vector <brics_actuator::JointValue> gripperJointPositions;

			vector <std::string> gripperJointNames;

			gripperJointPositions.resize(2);
			gripperJointNames.resize(2);

			//ROS_INFO("initializing gripper");
			gripperJointNames[0] = "gripper_finger_joint_l";
			gripperJointNames[1] = "gripper_finger_joint_r";

			for (unsigned int i = 0; i < 2; ++i)
			{
				gripperJointPositions[i].joint_uri = gripperJointNames[i].c_str();
				gripperJointPositions[i].value = values[i];
				gripperJointPositions[i].unit = std::string("m");
			}

			// Store last values for later.
			_last_gripper_command = values;

			command.positions = gripperJointPositions;
			ROS_INFO("the values are %f %f ", values[0], values[1]);
			_move_gripper_pub.publish(command);
			sout << "True";
			return true;
		}
		sout << "True";
		return false;
	}


	bool MoveBase(ostream& sout, istream& sinput)
	{
		if (ros::ok() && !_paused)
		{
			assembly_common::BasePose srv;

			std::string valuesString;
			sinput >> valuesString;

			ROS_INFO("input %s", valuesString.c_str());

			vector<std::string> valuestokens;
			boost::split(valuestokens, valuesString, boost::is_any_of("\t,"));

			srv.request.x = boost::lexical_cast<double>(valuestokens[0]);
			srv.request.y = boost::lexical_cast<double>(valuestokens[1]);
			srv.request.theta = boost::lexical_cast<double>(valuestokens[2]);
			srv.request.threshold = boost::lexical_cast<double>(valuestokens[3]);
			srv.request.angle_threshold = boost::lexical_cast<double>(valuestokens[4]);
			srv.request.arm_offset = std::strcmp(valuestokens[5].c_str(), "True");
			srv.request.frame = valuestokens[6];
			return client.call(srv);
		}
		sout << "True";
		return false;
	}
	virtual ~YoubotController()
	{
	}

	void JointStateCallback(const sensor_msgs::JointState::ConstPtr& msg)
	{
		if (_paused)
		{
                    return;
		}
		if (msg->name.at(0) != string("arm_joint_1"))   // wheel joints are published to the same topic. Ignore them.
		{
			return;
		}

		std::vector <double> joint_angles;
		std::vector <double> joint_torques;

		// subtract the offset from the read values
		for (unsigned int i = 0; i < (msg->position).size(); i++)
		{
			joint_angles.push_back((msg->position).at(i) - _offset.at(i));
			joint_torques.push_back((msg->effort).at(i));
		}

		_probot->SetDOFValues(joint_angles, 0); // The 0 is to not check limits.
		_probot->SetDOFTorqueLimits(joint_torques); // Hijacking the limits array to carry the actual values.
	}

	virtual bool Init(RobotBasePtr robot, const std::vector<int>& dofindices, int nControlTransformation)
	{
		_probot = robot;

		if ( !!_probot )
		{
			_dofindices = dofindices;
			_nControlTransformation = nControlTransformation;
		}
		// intialize ros and the ros node handle
		_pn = new ros::NodeHandle();

		// create ros subscriber for joint messages.
		_joint_angles_sub = _pn->subscribe(("/" + string(_probot->GetName()) + "/joint_states").c_str(), 1, &YoubotController::JointStateCallback, this);

		// start the move base client
		client = _pn->serviceClient<assembly_common::BasePose>("move_base");

        _move_arm_pub = _pn->advertise<brics_actuator::JointPositions>(("/" + string(_probot->GetName()) + "/arm_1/arm_controller/position_command").c_str(), 1);
        _move_gripper_pub = _pn->advertise<brics_actuator::JointPositions>(("/" + string(_probot->GetName()) + "/arm_1/gripper_controller/position_command").c_str(), 1);
        _move_base_pub = _pn->advertise<geometry_msgs::Twist>(("/" + string(_probot->GetName()) + "/cmd_vel").c_str(), 1);

		_offset.clear();
		double offsetvals[] = {2.950, 1.1345, -2.5482, 1.7890, 2.9234, 0.0, 0.0 , 0.0};
		for (int i = 0 ; i < 8; i++)
		{
			_offset.push_back(offsetvals[i]);
		}
        
        _paused = false;

		return true;
	}

	virtual void Reset(int options)
	{
	}

	virtual const std::vector<int>& GetControlDOFIndices() const
	{
		return _dofindices;
	}

	virtual int IsControlTransformation() const
	{
		return _nControlTransformation;
	}

	virtual bool SetDesired(const std::vector<dReal>& values, TransformConstPtr trans)
	{
		return true;
	}

	virtual bool SetPath(TrajectoryBaseConstPtr ptraj)
	{
	    std::ostream str(std::cout.rdbuf());
	    ptraj->serialize(str);
	
	    at_goal = false;
	    at_arm_goal = false;
	    waypoint_idx = 0;
	    arm_waypoint_idx = 1;
	    this->traj = ptraj;
	    done = false;
	    
	    std::cout << "IN SET PATH WOOO" << std::endl;
	    
		return true;
	}

	virtual void SimulationStep(dReal fTimeElapsed)
	{
	    if (traj != NULL){

	        ConfigurationSpecification cs = traj->GetConfigurationSpecification();
	        ConfigurationSpecification::Group affine_transform;
	        bool move_base = false;
	        try{
	            affine_transform = cs.GetGroupFromName("affine_transform");
	            move_base = true;
	        }
	        catch (exception& e){
	            move_base = false;
	        }
	        if (move_base){ //in this case, we are operating with the base
	            std::cout << "Moving Base" << std::endl;
	            int pos_start = affine_transform.offset;
	            ConfigurationSpecification::Group affine_velocities = cs.GetGroupFromName("affine_velocities");
	            int vel_start = affine_velocities.offset;
	
	
	            if (!done){ //if there's no trajectory, just return
	                if (traj->GetNumWaypoints() > waypoint_idx || !at_goal){ //if we're at the goal, also just return

	                     
	                        at_goal = false;
	                        std::vector< dReal > waypoint;
	                        
	                        traj->GetWaypoint(waypoint_idx, waypoint);
	                        
	                        double yaw_goal = waypoint[pos_start + 2];
	                        
	                        //create matrix:
	                        RaveVector<dReal> target_quat = geometry::quatFromAxisAngle(RaveVector<dReal>(0, 0, 1), yaw_goal);
	                        Transform target(target_quat,RaveVector<dReal>(waypoint[pos_start + 0],waypoint[pos_start + 1],0.0) ); 
	                        TransformMatrix cur = _probot->GetTransform();
	                        
	                        Transform target_in_frame = cur.inverse() * target;
	                        
	                        double x_goal = target_in_frame.trans[0];
	                        double y_goal = target_in_frame.trans[1];
	                        
	                        double speed_x = 0.05; //std::fabs(waypoint[vel_start + 3]);
	                        double speed_y = 0.05; // std::fabs(waypoint[vel_start + 4]);
	                        double speed_yaw = 0.1; //std::fabs(waypoint[vel_start + 5]);
	                        double dist_thresh = std::sqrt(speed_x * speed_x + speed_y * speed_y) / 2.0;
	                        double yaw_thresh = speed_yaw / 2.0;              

                            double yaw_diff = yaw_goal - std::atan2(cur.rot(1,0), cur.rot(0,0));
	                        
	                        double dist2 = std::sqrt(x_goal * x_goal + y_goal * y_goal);
	                        
	                        //normalize:
	                        
	                        double x_vel;
	                        double y_vel;
	                        double z_vel = 0;
	                        double roll_vel = 0;
	                        double pitch_vel = 0;
	                        double yaw_vel;
	                        
                            std::cout << "x_goal is " << x_goal << std::endl;
                            std::cout << "y_goal is " << y_goal << std::endl;
	                        std::cout << "distance is " << dist2 << std::endl;
	                        std::cout << "thresh is " << dist_thresh << std::endl;
	                        std::cout << "ang is " << yaw_diff << std::endl;
	                        std::cout << "ang thresh is " << yaw_thresh << std::endl;
	                        
	                        if (dist2 < dist_thresh && std::fabs(yaw_diff) < yaw_thresh){
	                            at_goal = true;
	                            waypoint_idx += 1;
	                        
	                        }else{
	                        
	                            if (dist2 < dist_thresh){
	                                x_vel = 0;
	                                y_vel = 0;
	                            }else{
	                            
	                                x_vel = x_goal / dist2 * speed_x;
	                                y_vel = y_goal / dist2 * speed_y;
	                                double x_sign = copysign(1.0, x_vel);
	                                double y_sign = copysign(1.0, y_vel);
	                               
	                                double max_speed = 0.2;
	                                
	                                x_vel = std::fabs(x_vel) < max_speed ? x_vel : max_speed * x_sign;
	                                y_vel = std::fabs(y_vel) < max_speed ? y_vel : max_speed * y_sign;
	                                
	                                std::cout << "x_vel is " << x_vel << std::endl;
                                    std::cout << "y_vel is " << y_vel << std::endl;
	                                
	                                
	                            }
	                            
	                            if (std::fabs(yaw_diff) < yaw_thresh){
	                                yaw_vel = 0;
	                            }else{
	                                yaw_vel = speed_yaw * copysign(1.0, yaw_diff);
	                            }
	                            
	                            geometry_msgs::Twist command;
	                            command.linear.x = x_vel;
	                            command.linear.y = y_vel;
	                            command.linear.z = z_vel;
	                            command.angular.x = roll_vel;
	                            command.angular.y = pitch_vel;
	                            command.angular.z = yaw_vel;
	                            
	                            _move_base_pub.publish(command);
	                            
	                            
	                        }
	                        
	                        
	                    
	                }else if (traj->GetNumWaypoints() <= waypoint_idx && at_goal){
	                    done = true;
	                    //done, so stop
	                    geometry_msgs::Twist command;
	                    command.linear.x = 0.0;
	                    command.linear.y = 0.0;
	                    command.linear.z = 0.0;
	                    command.angular.x = 0.0;
	                    command.angular.y = 0.0;
	                    command.angular.z = 0.0;
	                            
	                    _move_base_pub.publish(command);
	                    
	                }
	            }
	            
	        }else{ //let's move the arm
	            ConfigurationSpecification::Group joint_velocities = cs.GetGroupFromName("joint_velocities");
	            ConfigurationSpecification::Group joint_values = cs.GetGroupFromName("joint_values");
	            int pos_start = joint_values.offset;
	            int vel_start = joint_velocities.offset;
	            
	            std::vector< dReal > waypoint;
	            if (traj->GetNumWaypoints() > arm_waypoint_idx){
	                traj->GetWaypoint(arm_waypoint_idx, waypoint);
	                
	                /*
	                for (int i = 0; i < waypoint.size(); i++){
	                    std::cout << waypoint[i] << std::endl;
	                }
	                */
	                std::ostream str(std::cout.rdbuf());
	                //traj->serialize(str);
	                
	                /*
	                std::cout << str << std::endl;
	                
	                
	                std::cout << "pos start is " << pos_start << std::endl;
	                std::cout << "vel start is " << vel_start << std::endl;
	            
	                std::cout << "Movin' the arm to waypoint " << arm_waypoint_idx << std::endl;
	                */
	                //std::cout << "Moving!" << std::endl;
	                MoveArm(waypoint); //TODO: offsets?
	                ros::Duration(0.5).sleep();
	                //std::cout << "MovED!" << std::endl;
	            }
	            
	            std::vector<double> current_arm_config;
	            static const int arr[] = {0, 1, 2, 3, 4};
                vector<int> dofindices (arr, arr + sizeof(arr) / sizeof(arr[0]) );
	            
	            
		        _probot->GetDOFValues(current_arm_config, dofindices);
		        
	            bool arm_done = true;
	            
	            
		        if (_last_arm_command.empty())
		        {
			        arm_done = true;
		        }
		        else
		        {
			        for (unsigned int i = 0; i < 5; i++)
			        {
			            std::cout << "diff : " << std::fabs( _last_arm_command[i] - (current_arm_config[i] + _offset[i]) ) << std::endl;
				        if (std::fabs( _last_arm_command[i] - (current_arm_config[i] + _offset[i]) ) > 0.1)
				        {
					        arm_done = arm_done && false;
				        }
				        else
				        {
					        arm_done = arm_done && true;
				        }
			        }
		        }
		        std::cout << "arm done " << arm_done << std::endl;
		        std::cout << "waypoint " << arm_waypoint_idx << std::endl;
		        if (arm_done || traj->GetNumWaypoints() > arm_waypoint_idx){
		            if (arm_done && traj->GetNumWaypoints() > arm_waypoint_idx){
		                arm_waypoint_idx++;
		            }
		        }
		        if (arm_done && traj->GetNumWaypoints() <= arm_waypoint_idx){
		            
		            std::cout << "AT GOAL!" << std::endl;
		            at_arm_goal = true && arm_done;
		        }
	            
	            
	            
	        
	        
	        }
	    }
		ros::spinOnce();
	}

	virtual bool IsDone()
	{
		bool arm_done = at_arm_goal;
		bool gripper_done = true;
		bool base_done = false;
		std::vector<int> dofindices;

		
        gripper_done = true;

		if (traj->GetNumWaypoints() > waypoint_idx || !at_goal){
		    base_done = true;
		}
        std::cout << "Arm Done " << arm_done << std::endl;
        std::cout << "Gripper Done " << gripper_done << std::endl;
        std::cout << "Base Done " << base_done << std::endl;
		return arm_done && gripper_done && base_done;
	}

	virtual dReal GetTime() const
	{
		return 0;
	}
	virtual RobotBasePtr GetRobot() const
	{
		return _probot;
	}

private:

	RobotBasePtr _probot;               ///< controlled body
	std::vector<int> _dofindices;
	int _nControlTransformation;
	ros::Subscriber _joint_angles_sub;
	ros::Publisher _move_arm_pub;
	ros::Publisher _move_gripper_pub;
	ros::Publisher _move_base_pub;
	ros::NodeHandle* _pn;
	ros::ServiceServer service;
	ros::ServiceClient client;
	EnvironmentBasePtr _penv;
	std::vector<double> _offset;
        bool _paused;

	std::vector<double> _last_arm_command;
	std::vector<double> _last_gripper_command;

    //trajectory control local variables
    bool at_goal;
    bool at_arm_goal;
    int waypoint_idx;
    int arm_waypoint_idx;
    TrajectoryBaseConstPtr traj;
    bool done;
    
    
    //TODO: thresh and velocity
    
};

ControllerBasePtr CreateYoubotController(EnvironmentBasePtr penv, std::istream& sinput)
{
	return ControllerBasePtr(new YoubotController(penv, sinput));
}

